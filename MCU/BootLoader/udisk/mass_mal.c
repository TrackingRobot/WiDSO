/*
 * 存储器驱动模块 for stm32f103c8 & stm32l151c8
 * eleqian 2014-10-23
 */

#include "hw_config.h"
#include "mass_mal.h"
#include "string.h"
#ifdef MAL_SPI_FLASH
#include "spi_flash.h"
#endif // MAL_SPI_FLASH

// 设备信息
uint32_t Mass_Block_Size[MAX_LUN];      // 块大小
uint32_t Mass_Block_Count[MAX_LUN];     // 块数目
uint32_t Mass_Memory_Size[MAX_LUN];     // 空间大小

#ifdef MCU_STM32F103C8
// 内部Flash磁盘文件系统空间
// 基于RAM可以避免使用Flash，同时保证每次更新bin都在固定位置
// 空间分配：1k引导扇区(只使用前512Byte) + 1k FAT表+ 1k根目录
static uint8_t Mass_FAT[1024 * 3];

// 内部Flash磁盘的启动扇区
// 磁盘参数：扇区大小1k，1个引导扇区，1个FAT表，1个根目录扇区
// 总大小115k，可用空间115-3=112k
const unsigned char Mass_BootSector[512] = {
	0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x04, 0x01, 0x01, 0x00, 
	0x01, 0x20, 0x00, 0x73, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x0D, 0x89, 0xE0, 0x04, 0x55, 0x53, 0x42, 0x5F, 0x42, 
	0x4C, 0x00, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x36, 0x00, 0x20, 0x20, 0x33, 0xC9, 
	0x8E, 0xD1, 0xBC, 0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E, 0xC0, 0xFC, 0xBD, 0x00, 0x7C, 
	0x38, 0x4E, 0x24, 0x7D, 0x24, 0x8B, 0xC1, 0x99, 0xE8, 0x3C, 0x01, 0x72, 0x1C, 0x83, 0xEB, 0x3A, 
	0x66, 0xA1, 0x1C, 0x7C, 0x26, 0x66, 0x3B, 0x07, 0x26, 0x8A, 0x57, 0xFC, 0x75, 0x06, 0x80, 0xCA, 
	0x02, 0x88, 0x56, 0x02, 0x80, 0xC3, 0x10, 0x73, 0xEB, 0x33, 0xC9, 0x8A, 0x46, 0x10, 0x98, 0xF7, 
	0x66, 0x16, 0x03, 0x46, 0x1C, 0x13, 0x56, 0x1E, 0x03, 0x46, 0x0E, 0x13, 0xD1, 0x8B, 0x76, 0x11, 
	0x60, 0x89, 0x46, 0xFC, 0x89, 0x56, 0xFE, 0xB8, 0x20, 0x00, 0xF7, 0xE6, 0x8B, 0x5E, 0x0B, 0x03, 
	0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x46, 0xFC, 0x11, 0x4E, 0xFE, 0x61, 0xBF, 0x00, 0x00, 0xE8, 0xE6, 
	0x00, 0x72, 0x39, 0x26, 0x38, 0x2D, 0x74, 0x17, 0x60, 0xB1, 0x0B, 0xBE, 0xA1, 0x7D, 0xF3, 0xA6, 
	0x61, 0x74, 0x32, 0x4E, 0x74, 0x09, 0x83, 0xC7, 0x20, 0x3B, 0xFB, 0x72, 0xE6, 0xEB, 0xDC, 0xA0, 
	0xFB, 0x7D, 0xB4, 0x7D, 0x8B, 0xF0, 0xAC, 0x98, 0x40, 0x74, 0x0C, 0x48, 0x74, 0x13, 0xB4, 0x0E, 
	0xBB, 0x07, 0x00, 0xCD, 0x10, 0xEB, 0xEF, 0xA0, 0xFD, 0x7D, 0xEB, 0xE6, 0xA0, 0xFC, 0x7D, 0xEB, 
	0xE1, 0xCD, 0x16, 0xCD, 0x19, 0x26, 0x8B, 0x55, 0x1A, 0x52, 0xB0, 0x01, 0xBB, 0x00, 0x00, 0xE8, 
	0x3B, 0x00, 0x72, 0xE8, 0x5B, 0x8A, 0x56, 0x24, 0xBE, 0x0B, 0x7C, 0x8B, 0xFC, 0xC7, 0x46, 0xF0, 
	0x3D, 0x7D, 0xC7, 0x46, 0xF4, 0x29, 0x7D, 0x8C, 0xD9, 0x89, 0x4E, 0xF2, 0x89, 0x4E, 0xF6, 0xC6, 
	0x06, 0x96, 0x7D, 0xCB, 0xEA, 0x03, 0x00, 0x00, 0x20, 0x0F, 0xB6, 0xC8, 0x66, 0x8B, 0x46, 0xF8, 
	0x66, 0x03, 0x46, 0x1C, 0x66, 0x8B, 0xD0, 0x66, 0xC1, 0xEA, 0x10, 0xEB, 0x5E, 0x0F, 0xB6, 0xC8, 
	0x4A, 0x4A, 0x8A, 0x46, 0x0D, 0x32, 0xE4, 0xF7, 0xE2, 0x03, 0x46, 0xFC, 0x13, 0x56, 0xFE, 0xEB, 
	0x4A, 0x52, 0x50, 0x06, 0x53, 0x6A, 0x01, 0x6A, 0x10, 0x91, 0x8B, 0x46, 0x18, 0x96, 0x92, 0x33, 
	0xD2, 0xF7, 0xF6, 0x91, 0xF7, 0xF6, 0x42, 0x87, 0xCA, 0xF7, 0x76, 0x1A, 0x8A, 0xF2, 0x8A, 0xE8, 
	0xC0, 0xCC, 0x02, 0x0A, 0xCC, 0xB8, 0x01, 0x02, 0x80, 0x7E, 0x02, 0x0E, 0x75, 0x04, 0xB4, 0x42, 
	0x8B, 0xF4, 0x8A, 0x56, 0x24, 0xCD, 0x13, 0x61, 0x61, 0x72, 0x0B, 0x40, 0x75, 0x01, 0x42, 0x03, 
	0x5E, 0x0B, 0x49, 0x75, 0x06, 0xF8, 0xC3, 0x41, 0xBB, 0x00, 0x00, 0x60, 0x66, 0x6A, 0x00, 0xEB, 
	0xB0, 0x42, 0x4F, 0x4F, 0x54, 0x4D, 0x47, 0x52, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x52, 0x65, 
	0x6D, 0x6F, 0x76, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 
	0x68, 0x65, 0x72, 0x20, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2E, 0xFF, 0x0D, 0x0A, 0x44, 0x69, 0x73, 
	0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xFF, 0x0D, 0x0A, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 
	0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x74, 0x61, 
	0x72, 0x74, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xCB, 0xD8, 0x55, 0xAA
};
#endif //MCU_STM32F103C8

#ifdef MCU_STM32L151C8
// 内部Flash磁盘文件系统空间
// 基于RAM可以避免使用Flash，同时保证每次更新bin都在固定位置
// 空间分配：512B引导扇区 + 512B FAT表+ 512B根目录
static uint8_t Mass_FAT[512 * 3];

// 内部Flash磁盘的启动扇区
// 磁盘参数：扇区大小512B，1个引导扇区，1个FAT表，1个根目录扇区
// 总大小49.5k，可用空间49.5-1.5=48k
const unsigned char Mass_BootSector[512] = {
	0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x01, 0x00, 
	0x01, 0x10, 0x00, 0x63, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x0D, 0x87, 0xE0, 0x04, 0x55, 0x53, 0x42, 0x5F, 0x42, 
	0x4C, 0x00, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x36, 0x00, 0x20, 0x20, 0x33, 0xC9, 
	0x8E, 0xD1, 0xBC, 0xF0, 0x7B, 0x8E, 0xD9, 0xB8, 0x00, 0x20, 0x8E, 0xC0, 0xFC, 0xBD, 0x00, 0x7C, 
	0x38, 0x4E, 0x24, 0x7D, 0x24, 0x8B, 0xC1, 0x99, 0xE8, 0x3C, 0x01, 0x72, 0x1C, 0x83, 0xEB, 0x3A, 
	0x66, 0xA1, 0x1C, 0x7C, 0x26, 0x66, 0x3B, 0x07, 0x26, 0x8A, 0x57, 0xFC, 0x75, 0x06, 0x80, 0xCA, 
	0x02, 0x88, 0x56, 0x02, 0x80, 0xC3, 0x10, 0x73, 0xEB, 0x33, 0xC9, 0x8A, 0x46, 0x10, 0x98, 0xF7, 
	0x66, 0x16, 0x03, 0x46, 0x1C, 0x13, 0x56, 0x1E, 0x03, 0x46, 0x0E, 0x13, 0xD1, 0x8B, 0x76, 0x11, 
	0x60, 0x89, 0x46, 0xFC, 0x89, 0x56, 0xFE, 0xB8, 0x20, 0x00, 0xF7, 0xE6, 0x8B, 0x5E, 0x0B, 0x03, 
	0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x46, 0xFC, 0x11, 0x4E, 0xFE, 0x61, 0xBF, 0x00, 0x00, 0xE8, 0xE6, 
	0x00, 0x72, 0x39, 0x26, 0x38, 0x2D, 0x74, 0x17, 0x60, 0xB1, 0x0B, 0xBE, 0xA1, 0x7D, 0xF3, 0xA6, 
	0x61, 0x74, 0x32, 0x4E, 0x74, 0x09, 0x83, 0xC7, 0x20, 0x3B, 0xFB, 0x72, 0xE6, 0xEB, 0xDC, 0xA0, 
	0xFB, 0x7D, 0xB4, 0x7D, 0x8B, 0xF0, 0xAC, 0x98, 0x40, 0x74, 0x0C, 0x48, 0x74, 0x13, 0xB4, 0x0E, 
	0xBB, 0x07, 0x00, 0xCD, 0x10, 0xEB, 0xEF, 0xA0, 0xFD, 0x7D, 0xEB, 0xE6, 0xA0, 0xFC, 0x7D, 0xEB, 
	0xE1, 0xCD, 0x16, 0xCD, 0x19, 0x26, 0x8B, 0x55, 0x1A, 0x52, 0xB0, 0x01, 0xBB, 0x00, 0x00, 0xE8, 
	0x3B, 0x00, 0x72, 0xE8, 0x5B, 0x8A, 0x56, 0x24, 0xBE, 0x0B, 0x7C, 0x8B, 0xFC, 0xC7, 0x46, 0xF0, 
	0x3D, 0x7D, 0xC7, 0x46, 0xF4, 0x29, 0x7D, 0x8C, 0xD9, 0x89, 0x4E, 0xF2, 0x89, 0x4E, 0xF6, 0xC6, 
	0x06, 0x96, 0x7D, 0xCB, 0xEA, 0x03, 0x00, 0x00, 0x20, 0x0F, 0xB6, 0xC8, 0x66, 0x8B, 0x46, 0xF8, 
	0x66, 0x03, 0x46, 0x1C, 0x66, 0x8B, 0xD0, 0x66, 0xC1, 0xEA, 0x10, 0xEB, 0x5E, 0x0F, 0xB6, 0xC8, 
	0x4A, 0x4A, 0x8A, 0x46, 0x0D, 0x32, 0xE4, 0xF7, 0xE2, 0x03, 0x46, 0xFC, 0x13, 0x56, 0xFE, 0xEB, 
	0x4A, 0x52, 0x50, 0x06, 0x53, 0x6A, 0x01, 0x6A, 0x10, 0x91, 0x8B, 0x46, 0x18, 0x96, 0x92, 0x33, 
	0xD2, 0xF7, 0xF6, 0x91, 0xF7, 0xF6, 0x42, 0x87, 0xCA, 0xF7, 0x76, 0x1A, 0x8A, 0xF2, 0x8A, 0xE8, 
	0xC0, 0xCC, 0x02, 0x0A, 0xCC, 0xB8, 0x01, 0x02, 0x80, 0x7E, 0x02, 0x0E, 0x75, 0x04, 0xB4, 0x42, 
	0x8B, 0xF4, 0x8A, 0x56, 0x24, 0xCD, 0x13, 0x61, 0x61, 0x72, 0x0B, 0x40, 0x75, 0x01, 0x42, 0x03, 
	0x5E, 0x0B, 0x49, 0x75, 0x06, 0xF8, 0xC3, 0x41, 0xBB, 0x00, 0x00, 0x60, 0x66, 0x6A, 0x00, 0xEB, 
	0xB0, 0x42, 0x4F, 0x4F, 0x54, 0x4D, 0x47, 0x52, 0x20, 0x20, 0x20, 0x20, 0x0D, 0x0A, 0x52, 0x65, 
	0x6D, 0x6F, 0x76, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x73, 0x20, 0x6F, 0x72, 0x20, 0x6F, 0x74, 
	0x68, 0x65, 0x72, 0x20, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x2E, 0xFF, 0x0D, 0x0A, 0x44, 0x69, 0x73, 
	0x6B, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xFF, 0x0D, 0x0A, 0x50, 0x72, 0x65, 0x73, 0x73, 0x20, 
	0x61, 0x6E, 0x79, 0x20, 0x6B, 0x65, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x72, 0x65, 0x73, 0x74, 0x61, 
	0x72, 0x74, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xCB, 0xD8, 0x55, 0xAA
};
#endif //MCU_STM32L151C8

// 磁盘卷标目录项（"USB_BL"）
static const uint8_t Mass_LabelEntry[32] = {
	0x55, 0x53, 0x42, 0x5F, 0x42, 0x4C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x7D, 0x2C, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/*-----------------------------------*/

// 擦除内部Flash
// 参数：擦除地址(必须为页开始地址)，擦除大小(必须为页大小整数倍)
uint16_t FLASH_If_Erase(uint32_t SectorAddress, uint32_t EraseLength)
{
    uint16_t i;

#ifdef MCU_STM32L151C8
    FLASH_ClearFlag(FLASH_FLAG_PGAERR | FLASH_FLAG_OPTVERR);
#endif // MCU_STM32L151C8

    for (i = 0; i < EraseLength; i += INTER_FLASH_PAGE_SIZE) {
        FLASH_ErasePage(SectorAddress + i);
    }

    return MAL_OK;
}

// 写内部Flash
// 参数：写地址，写内容指针，写字节数(必须是4的倍数)
// 返回：MAL_OK/MAL_FAIL
uint16_t FLASH_If_Write(uint32_t WriteAddress, const uint8_t *Writebuff, uint32_t DataLength)
{
#ifdef MCU_STM32L151C8
#if 0   // 快速写Flash，但需要部分代码在SRAM运行
    __IO uint32_t *malPointer = (uint32_t *)Writebuff;
    __IO uint32_t *memPointer = (uint32_t *)WriteAddress;
    __IO uint32_t memBuffer[32]; // Temporary buffer holding data that will be written in a half-page space
    __IO uint32_t *mempBuffer;
    __IO uint32_t *tmp;

    if (DataLength & 0x3) { // Not an aligned data
        /*for (idx = DataLength; idx < ((DataLength & 0xFFFC) + 4); idx++) {
            MAL_Buffer[idx] = 0xFF;
        }*/
        return MAL_FAIL;
    }

    // Initialize the intermediate buffer pointer
    mempBuffer = memBuffer;

    // If the address is not aligned to half-page fill the first location with existing data
    if (((uint32_t)memPointer & 0x7F) != 0) {
        // get the aligned address
        tmp = (uint32_t *)((uint32_t)memPointer & 0xFFFFFF80);
        // Read the first part from the memory
        while (tmp < memPointer) {
            *(uint32_t *)(mempBuffer++) = *(uint32_t *)(tmp++);
        }
    }

    while (malPointer < (uint32_t *)(Writebuff + DataLength)) {
        // Fill with the received buffer
        while (mempBuffer < (memBuffer + 32)) {
            // If there are still data available in the received buffer
            if (malPointer < ((uint32_t *)Writebuff + DataLength)) {
                *(uint32_t *)(mempBuffer++) = *(uint32_t *)(malPointer++);
            } else {
                // no more data available in the received buffer: fill remaining with dummy 0
                *(uint32_t *)(mempBuffer++) = 0;
            }
        }
        // Write the buffer to the memory
        FLASH_ProgramHalfPage(((uint32_t)memPointer & 0xFFFFFF80), (uint32_t *)(memBuffer));
        // Increment the memory pointer
        memPointer = (uint32_t *)(((uint32_t)memPointer & 0xFFFFFF80) + (32 * 4));
        // Reinitialize the intermediate buffer pointer
        mempBuffer = memBuffer;
    }
#else
    uint32_t idx = 0;

    // Data received are Word multiple
    for (idx = 0; idx <  DataLength; idx = idx + 4) {
        FLASH_FastProgramWord(WriteAddress, *(uint32_t *)(Writebuff + idx));
        WriteAddress += 4;
    }
#endif
#endif //MCU_STM32L151C8

#ifdef MCU_STM32F103C8
    uint32_t idx = 0;

    // Data received are Word multiple
    for (idx = 0; idx <  DataLength; idx = idx + 4) {
        FLASH_ProgramWord(WriteAddress, *(uint32_t *)(Writebuff + idx));
        WriteAddress += 4;
    }
#endif //MCU_STM32F103C8

    return MAL_OK;
}

// 读内部Flash
// 参数：读地址，数据缓冲区，读字节数
// 返回：MAL_OK
uint16_t FLASH_If_Read(uint32_t ReadAddress, uint8_t *Readbuff, uint32_t DataLength)
{
    uint32_t idx = 0;
    __IO uint32_t *malPointer = (uint32_t *)Readbuff;
    __IO uint32_t *memPointer = (uint32_t *)ReadAddress;

    for (idx = 0; idx < DataLength; idx += 4) {
        *malPointer++ = *memPointer++;
    }

    return MAL_OK;;
}

/*-----------------------------------*/

// MAL层初始化
// 参数：设备序号
// 返回：MAL_OK/MAL_FAIL
uint16_t MAL_Init(uint8_t lun)
{
    switch (lun) {
    case 0:
#ifdef MCU_STM32L151C8
        FLASH_Unlock();
        FLASH_ClearFlag(FLASH_FLAG_OPTVERRUSR);
        // 复制启动扇区到RAM
        memcpy(&Mass_FAT[0x0], Mass_BootSector, sizeof(Mass_BootSector));
        // 添加磁盘卷标到目录表
        memcpy(&Mass_FAT[0x400], Mass_LabelEntry, sizeof(Mass_LabelEntry));
#endif //MCU_STM32L151C8
#ifdef MCU_STM32F103C8
        FLASH_Unlock();
        FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);	
        // 复制启动扇区到RAM
        memcpy(&Mass_FAT[0x0], Mass_BootSector, sizeof(Mass_BootSector));
        // 添加磁盘卷标到目录表
        memcpy(&Mass_FAT[0x800], Mass_LabelEntry, sizeof(Mass_LabelEntry));
#endif //MCU_STM32F103C8
        break;
#ifdef MAL_SPI_FLASH
    case 1:
        SPI_Flash_Init();
        //SPI_Flash_ReadJEDECID();
        //SPI_Flash_ReadStatus();
        //SPI_Flash_ProtectionDisable();
        break;
#endif //MAL_SPI_FLASH
    default:
        return MAL_FAIL;
    }

    return MAL_OK;
}

// MAL层写数据
// 参数：设备序号，写地址，数据指针，数据大小
// 返回：MAL_OK/MAL_FAIL
uint16_t MAL_Write(uint8_t lun, uint32_t Memory_Offset, const uint8_t *Writebuff, uint16_t Transfer_Length)
{
    switch (lun) {
    case 0:
        if (Memory_Offset < sizeof(Mass_FAT)) {
            memcpy(Mass_FAT + Memory_Offset, Writebuff, Transfer_Length);
        } else {
            Memory_Offset -= sizeof(Mass_FAT);
            FLASH_If_Erase(INTER_FLASH_BASE_ADDR + Memory_Offset, Transfer_Length);
            FLASH_If_Write(INTER_FLASH_BASE_ADDR + Memory_Offset, Writebuff, Transfer_Length);
        }
        break;
#ifdef MAL_SPI_FLASH
    case 1:
        SPI_Flash_SectorErase(Memory_Offset);
        SPI_Flash_Write(Memory_Offset, Writebuff, Transfer_Length);
        break;
#endif // MAL_SPI_FLASH
    default:
        return MAL_FAIL;
    }

    return MAL_OK;
}

// MAL层读数据
// 参数：设备序号，读地址，数据缓冲区，读大小
// 返回：MAL_OK/MAL_FAIL
uint16_t MAL_Read(uint8_t lun, uint32_t Memory_Offset, uint8_t *Readbuff, uint16_t Transfer_Length)
{
    switch (lun) {
    case 0:
        if (Memory_Offset < sizeof(Mass_FAT)) {
            memcpy(Readbuff, Mass_FAT + Memory_Offset, Transfer_Length);
        } else {
            Memory_Offset -= sizeof(Mass_FAT);
            FLASH_If_Read(INTER_FLASH_BASE_ADDR + Memory_Offset, Readbuff, Transfer_Length);
        }
        break;
#ifdef MAL_SPI_FLASH
    case 1:
        SPI_Flash_Read(Memory_Offset, Readbuff, Transfer_Length);
        break;
#endif // MAL_SPI_FLASH
    default:
        return MAL_FAIL;
    }

    return MAL_OK;
}

// MAL层获取信息
// 参数：设备序号
// 返回：MAL_OK/MAL_FAIL
uint16_t MAL_GetStatus(uint8_t lun)
{
    switch (lun) {
    case 0:
#if INTER_FLASH_PAGE_SIZE == 256
        // FAT文件系统要求最小扇区大小为512
        Mass_Block_Size[0] = INTER_FLASH_PAGE_SIZE * 2;
        Mass_Block_Count[0] = INTER_FLASH_PAGE_COUNT / 2;
#else
        Mass_Block_Size[0] = INTER_FLASH_PAGE_SIZE;
        Mass_Block_Count[0] = INTER_FLASH_PAGE_COUNT;
#endif // INTER_FLASH_PAGE_SIZE
        break;
#ifdef MAL_SPI_FLASH
    case 1:
        Mass_Block_Size[1] = SPI_FLASH_SECTOR_SIZE;
        Mass_Block_Count[1] = SPI_FLASH_SECTOR_COUNT;
        break;
#endif // MAL_SPI_FLASH
    default:
        return MAL_FAIL;
    }

    Mass_Memory_Size[lun] = Mass_Block_Size[lun] * Mass_Block_Count[lun];

    return MAL_OK;
}
